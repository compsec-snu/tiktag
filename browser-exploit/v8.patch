diff --git a/src/runtime/runtime-test.cc b/src/runtime/runtime-test.cc
index 78eb5e58deb..d0c16c86c20 100644
--- a/src/runtime/runtime-test.cc
+++ b/src/runtime/runtime-test.cc
@@ -14,6 +14,7 @@
 #include "src/base/macros.h"
 #include "src/base/numbers/double.h"
 #include "src/codegen/compiler.h"
+#include "src/codegen/cpu-features.h"
 #include "src/codegen/pending-optimization-table.h"
 #include "src/compiler-dispatcher/lazy-compile-dispatcher.h"
 #include "src/compiler-dispatcher/optimizing-compile-dispatcher.h"
@@ -51,6 +52,20 @@
 #include "src/wasm/wasm-engine.h"
 #endif  // V8_ENABLE_WEBASSEMBLY
 
+
+#include <assert.h>
+#include <string.h>
+
+#include <fcntl.h>
+#include <sched.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <errno.h>
+
+
+
 namespace v8 {
 namespace internal {
 
@@ -592,6 +607,561 @@ RUNTIME_FUNCTION(Runtime_PrepareFunctionForOptimization) {
   return ReadOnlyRoots(isolate).undefined_value();
 }
 
+RUNTIME_FUNCTION(Runtime_FlushAddress) {
+  HandleScope scope(isolate);
+  if (args.length() != 2) {
+    return CrashUnlessFuzzing(isolate);
+  }
+
+#if ! defined(USE_SIMULATOR) && defined(V8_TARGET_ARCH_ARM64)
+  Handle<Object> object = args.at(0);
+  uint64_t offset = PositiveNumberToUint64(args[1]);
+  void *backing_store = nullptr;
+  void *flush_addr = nullptr;
+
+  if (IsJSTypedArray(*object)) {
+    Handle<JSTypedArray> js_typed_array = Handle<JSTypedArray>::cast(object);
+    backing_store = static_cast<void*>(js_typed_array->DataPtr());
+    flush_addr = (void*)((char*)backing_store + offset);
+
+  } else if (IsJSArray(*object)) {
+    Handle<JSArray> js_array = Handle<JSArray>::cast(object);
+    backing_store = (void*)(js_array->elements().ptr()-1+8);
+    flush_addr = (void*)((char*)backing_store + offset);
+  }
+
+    asm volatile ("dsb sy":::"memory");
+    asm volatile ("isb");
+    asm volatile ("dc civac, %0"::"r"(flush_addr):"memory");
+    asm volatile ("dsb sy":::"memory");
+    asm volatile ("isb");
+#endif
+
+  return Smi::FromInt(1);
+}
+
+RUNTIME_FUNCTION(Runtime_FlushLength) {
+  HandleScope scope(isolate);
+  if (args.length() != 1) {
+    return CrashUnlessFuzzing(isolate);
+  }
+
+  int res = 1;
+#if ! defined(USE_SIMULATOR) && defined(V8_TARGET_ARCH_ARM64)
+  Handle<Object> object = args.at(0);
+  void *target = nullptr;
+  void *flush_addr = nullptr;
+
+
+   
+  if (IsJSTypedArray(*object)) {
+    Handle<JSTypedArray> js_typed_array = Handle<JSTypedArray>::cast(object);
+
+    target = (void*)(js_typed_array->ptr()-1);
+
+    void *backing_store = (void*)((char*)target+0x2c);
+    flush_addr = (void*)((uint64_t)((char*)target+ 0x24) & 0xffffffffffffffc0);
+    uint64_t cache_offset = ((uint64_t)(backing_store) & 0x3f);
+
+    // [0x00] JSTypedArray object
+    // [0x24]  - Length (Flushed)
+    // [0x2c]  - External Pointer Offset  (Not flushed)
+    // [0x34]  - Base offset (Not flushed)
+  
+    if ((cache_offset != 0) && (cache_offset != 4)) {
+      res = 0;
+      //return Smi::FromInt(0);
+    }
+  } else if (IsJSArray(*object)) {
+    Handle<JSArray> js_array = Handle<JSArray>::cast(object);
+    target = (void*)(js_array->ptr()-1);
+
+    // [0x0] JSArray object
+    // [0x8]  - ElementOsffset (Not Flushed)
+    // [0xc]  - Length         (Flushed)
+    flush_addr = (void*)((char*)target+0xc);
+    
+    if ((uintptr_t) flush_addr & 0x3f) { // 64-byte aligned?
+      // os << "not aligned..." << flush_addr << "\n";
+      //return Smi::FromInt(0);
+      res = 0;
+    }
+  }
+
+    //os << " - object : " << target << "\n";
+    //os << " - flush  : " << flush_addr <<"\n";
+
+    asm volatile ("dsb sy":::"memory");
+    asm volatile ("isb");
+    asm volatile ("dc civac, %0"::"r"(flush_addr):"memory");
+    asm volatile ("dsb sy":::"memory");
+    asm volatile ("isb");
+#endif
+
+  return Smi::FromInt(res);
+}
+
+
+volatile uint64_t shared_counter = 0;
+pthread_t shared_memory_timer_thread;
+
+static void* shared_memory_timer_func(void *) {
+  cpu_set_t cpu_set;
+  CPU_ZERO(&cpu_set);
+  CPU_SET(4, &cpu_set);
+  if(-1 == sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set)) {
+    printf("err %d\n", errno);
+  }
+  while (true) {
+    shared_counter += 1;
+  }
+  return NULL;
+}
+
+void start_timer() {
+  pthread_create(&shared_memory_timer_thread, NULL, &shared_memory_timer_func, (void*)NULL);
+  while (!shared_counter) {}
+}
+
+
+RUNTIME_FUNCTION(Runtime_VirtualCount) {
+  HandleScope scope(isolate);
+  if (args.length() != 2) {
+    return CrashUnlessFuzzing(isolate);
+  }
+  size_t start = 0, end = 0;
+  const volatile uint64_t* read_ptr = nullptr;
+
+  Handle<Object> object = args.at(0);
+  uint64_t offset = PositiveNumberToUint64(args[1]);
+
+  void *backing_store = nullptr;
+
+  if (IsJSTypedArray(*object)) {
+    Handle<JSTypedArray> js_typed_array = Handle<JSTypedArray>::cast(object);
+    backing_store = static_cast<void*>(js_typed_array->DataPtr());
+    read_ptr = (const uint64_t*)((char*)backing_store + offset);
+  } else if (IsJSArray(*object)) {
+    Handle<JSArray> js_array = Handle<JSArray>::cast(object);
+    backing_store = (void*)(js_array->elements().ptr()-1+8);
+    read_ptr = (const uint64_t*)((char*)backing_store +offset);
+  } else if (IsJSArrayBuffer(*object)) {
+    Handle<JSArrayBuffer> js_array_buffer = Handle<JSArrayBuffer>::cast(object);
+    backing_store = static_cast<void*>(js_array_buffer->backing_store());
+    read_ptr = (const uint64_t*)((char*)backing_store + offset);
+  }  else {
+  
+    size_t cnt = 0;
+#if ! defined(USE_SIMULATOR) && defined(V8_TARGET_ARCH_ARM64)
+  asm volatile("dsb sy\n":::"memory");
+  asm volatile("isb\n"); 
+    asm volatile("mrs %0, cntvct_el0\n":"=r"(cnt)::);
+  asm volatile("dsb sy\n":::"memory");
+  asm volatile("isb\n");
+
+#endif
+    return  *isolate->factory()->NewNumberFromInt64(cnt);
+  }
+#if ! defined(USE_SIMULATOR) && defined(V8_TARGET_ARCH_ARM64)
+  asm volatile("dsb sy\n":::"memory");
+  asm volatile("isb\n");
+  asm volatile("mrs %0, cntvct_el0\n":"=r"(start)::);
+  asm volatile("dsb sy\n":::"memory");
+  asm volatile("isb\n");
+  read_ptr = (const volatile uint64_t*)*read_ptr;
+  asm volatile("dsb sy\n":::"memory");
+  asm volatile("isb\n");
+  asm volatile("mrs %0, cntvct_el0\n":"=r"(end)::);
+  asm volatile("dsb sy\n":::"memory");
+  asm volatile("isb\n");
+#endif
+
+  return *isolate->factory()->NewNumberFromInt64(end - start + ((size_t)read_ptr * 0));
+}
+
+
+RUNTIME_FUNCTION(Runtime_VirtualCountLength) {
+  HandleScope scope(isolate);
+  if (args.length() != 2) {
+    return CrashUnlessFuzzing(isolate);
+  }
+  size_t start = 0, end = 0;
+  const volatile uint64_t* read_ptr = nullptr;
+  // jstypedarray only
+  Handle<JSTypedArray> js_typed_array = Handle<JSTypedArray>::cast(args.at(0));
+  uint32_t offset = Smi::cast(args[1]).value();
+  read_ptr = (const uint64_t*)((char*)(js_typed_array->ptr()-1) + offset);
+#if ! defined(USE_SIMULATOR) && defined(V8_TARGET_ARCH_ARM64)
+  asm volatile("dsb sy\n":::"memory");
+  asm volatile("isb\n");
+  asm volatile("mrs %0, cntvct_el0\n":"=r"(start)::);
+  asm volatile("dsb sy\n":::"memory");
+  asm volatile("isb\n");
+  read_ptr = (const volatile uint64_t*)*read_ptr;
+  asm volatile("dsb sy\n":::"memory");
+  asm volatile("isb\n");
+  asm volatile("mrs %0, cntvct_el0\n":"=r"(end)::);
+  asm volatile("dsb sy\n":::"memory");
+  asm volatile("isb\n");
+#endif
+
+  return *isolate->factory()->NewNumberFromInt64(end - start + ((size_t)read_ptr * 0));
+}
+
+
+RUNTIME_FUNCTION(Runtime_SharedCount) {
+  HandleScope scope(isolate);
+  if (args.length() != 2) {
+    return CrashUnlessFuzzing(isolate);
+  }
+  size_t start = 0, end = 0;
+  const volatile uint64_t* read_ptr = nullptr;
+
+  Handle<Object> object = args.at(0);
+  uint64_t offset = PositiveNumberToUint64(args[1]);
+  void *backing_store = nullptr;
+  if (IsJSTypedArray(*object)) {
+    Handle<JSTypedArray> js_typed_array = Handle<JSTypedArray>::cast(object);
+    backing_store = static_cast<void*>(js_typed_array->DataPtr());
+    read_ptr = (const uint64_t*)((char*)backing_store + offset);
+  } else if (IsJSArray(*object)) {
+    Handle<JSArray> js_array = Handle<JSArray>::cast(object);
+    backing_store = (void*)(js_array->elements().ptr()-1+8);
+    read_ptr = (const uint64_t*)((char*)backing_store + offset);
+  }
+
+
+#if ! defined(USE_SIMULATOR) && defined(V8_TARGET_ARCH_ARM64)
+  asm volatile("dsb sy\n":::"memory");
+  asm volatile("isb\n");
+  start = (size_t)shared_counter;
+  asm volatile("dsb sy\n":::"memory");
+  read_ptr = (const volatile uint64_t*)*read_ptr;
+  asm volatile("dsb sy\n":::"memory");
+  asm volatile("isb\n");
+  end = (size_t)shared_counter;
+#endif
+
+  return *isolate->factory()->NewNumberFromInt64(end - start + ((size_t)read_ptr * 0));
+}
+
+RUNTIME_FUNCTION(Runtime_SharedCountLength) {
+  HandleScope scope(isolate);
+  if (args.length() != 2) {
+    return CrashUnlessFuzzing(isolate);
+  }
+  size_t start = 0, end = 0;
+  const volatile uint64_t* read_ptr = nullptr;
+  // jstypedarray only
+  Handle<JSTypedArray> js_typed_array = Handle<JSTypedArray>::cast(args.at(0));
+  uint32_t offset = Smi::cast(args[1]).value();
+  read_ptr = (const uint64_t*)((char*)(js_typed_array->ptr()-1) + offset);
+#if ! defined(USE_SIMULATOR) && defined(V8_TARGET_ARCH_ARM64)
+  asm volatile("dsb sy\n":::"memory");
+  asm volatile("isb\n");
+  start = (size_t)shared_counter;
+  asm volatile("dsb sy\n":::"memory");
+  read_ptr = (const volatile uint64_t*)*read_ptr;
+  asm volatile("dsb sy\n":::"memory");
+  end = (size_t)shared_counter;
+  asm volatile("dsb sy\n":::"memory");
+  asm volatile("isb\n");
+#endif
+
+  return *isolate->factory()->NewNumberFromInt64(end - start + ((size_t)read_ptr * 0));
+}
+
+
+RUNTIME_FUNCTION(Runtime_StartSharedCount) {
+  HandleScope scope(isolate);
+  start_timer();
+  return *isolate->factory()->NewNumberFromInt64(0);
+}
+
+
+void **tagged_list = nullptr;
+int num_addr = 0;
+int init_mallopt = 0;
+#ifndef M_MEMTAG_TUNING
+  #define M_MEMTAG_TUNING (-102)
+#endif
+void initialize_tagged_addr(int isDouble, int num, int isUAF) {
+
+  //if (isUAF) {
+  //  mallopt(M_MEMTAG_TUNING, 1); // uaf tuning, OddEven=0
+  //}
+  tagged_list = (void**)(new uint64_t[num]);
+  num_addr = num;
+  
+  if (isDouble) {
+    for (int i=0; i < num; ++i) {
+      void *tagged_addr = new double[0x80];
+      for (int j=0; j < 0x80; ++j) {
+        ((double*)tagged_addr)[j] = (double)(num);
+      }
+      tagged_list[i] = tagged_addr;
+    }
+  } else {
+    for (int i=0; i < num; ++i) {
+      void *tagged_addr = new uint64_t[0x80];
+      for (int j=0; j < 0x80; ++j) {
+        ((uint64_t*)tagged_addr)[j] = (uint64_t)(num);
+      }
+      tagged_list[i] = tagged_addr;
+    }
+  }
+
+}
+
+// Arg 0: object
+// Output: target address offset from the object
+RUNTIME_FUNCTION(Runtime_GetTaggedAddress) {
+  HandleScope scope(isolate);
+  if (args.length() != 3) {
+    return CrashUnlessFuzzing(isolate);
+  }
+
+  Handle<Object> object = args.at(0);
+  uint32_t tag = Smi::cast(args[1]).value();
+  uint32_t idx = Smi::cast(args[2]).value();
+  void *backing_store = nullptr;
+  uint64_t elemsz = 4;
+  if (IsJSTypedArray(*object)) {
+    Handle<JSTypedArray> js_typed_array = Handle<JSTypedArray>::cast(object);
+    backing_store = static_cast<void*>(js_typed_array->DataPtr());
+    elemsz = js_typed_array->byte_length() / js_typed_array->GetLength();
+
+  } else if (IsJSArray(*object)) {
+    Handle<JSArray> js_array = Handle<JSArray>::cast(object);
+    backing_store = (void*)(js_array->elements().ptr()-1+8);
+    elemsz = 4;
+  } else {
+    return *isolate->factory()->NewNumberFromInt64((uint64_t)tagged_list[idx]);
+  }
+
+  uint64_t offset = 0;
+  // if tag > 0xf, return invalid addr.
+  if (tag <= 0xf) {  
+    void *tagged_addr = tagged_list[idx];
+    tagged_addr = (void*)(((uint64_t)(tagged_addr)+0x40+0x3f) & (~(uint64_t)0x3f));
+    void *stripped_addr = (void*)((uint64_t)tagged_addr & 0xffffffffffffff);
+    offset = (uint64_t)stripped_addr | ((uint64_t)tag << 56);
+    offset -= (uint64_t)backing_store;
+  }
+  offset /= elemsz;
+
+  return *isolate->factory()->NewNumberFromInt64(offset);
+}
+
+// Output: target tag
+RUNTIME_FUNCTION(Runtime_Initialize) {
+  HandleScope scope(isolate);
+  if (args.length() != 2) {
+    return CrashUnlessFuzzing(isolate);
+  }
+
+  int isDouble = Smi::cast(args[0]).value();
+  int isUAF = (isDouble >> 1) & 1;
+  int count = Smi::cast(args[1]).value();
+  initialize_tagged_addr(isDouble, count, isUAF);
+  
+  return ReadOnlyRoots(isolate).undefined_value();
+}
+
+
+// Output: target tag
+RUNTIME_FUNCTION(Runtime_FreeObj) {
+  HandleScope scope(isolate);
+  if (args.length() != 2) {
+    return CrashUnlessFuzzing(isolate);
+  }
+
+  int isDouble = Smi::cast(args[0]).value();
+  int idx = Smi::cast(args[1]).value();
+  if (isDouble) {
+    delete[] (double*)tagged_list[idx];
+  } else {
+    delete[] (uint64_t*)tagged_list[idx];
+  }
+  tagged_list[idx] = nullptr;
+
+  return ReadOnlyRoots(isolate).undefined_value();
+
+}
+
+// Output: target tag
+RUNTIME_FUNCTION(Runtime_AllocObj) {
+  HandleScope scope(isolate);
+  if (args.length() != 2) {
+    return CrashUnlessFuzzing(isolate);
+  }
+
+  int isDouble = Smi::cast(args[0]).value();
+  int idx = Smi::cast(args[1]).value();
+  void *tagged_addr;
+  if (isDouble) {
+    tagged_addr = new double[0x80];
+    for (int j=0; j < 0x80; ++j) {
+      ((double*)tagged_addr)[j] = (double)(idx);
+    }
+    tagged_list[idx] = tagged_addr; 
+  } else {
+    tagged_addr = new uint64_t[0x80];
+    for (int j=0; j < 0x80; ++j) {
+      ((uint64_t*)tagged_addr)[j] = (uint64_t)(idx);
+    }
+    tagged_list[idx] = tagged_addr;
+  }
+
+  int new_tag = (int)(((uint64_t)tagged_addr & 0xf00000000000000) >> 56);
+  
+  return Smi::FromInt(new_tag);
+}
+// Output: target tag
+RUNTIME_FUNCTION(Runtime_AccessObj) {
+  HandleScope scope(isolate);
+  if (args.length() != 4) {
+    return CrashUnlessFuzzing(isolate);
+  }
+
+  int isDouble = Smi::cast(args[0]).value();
+  int idx = Smi::cast(args[1]).value();
+  int offset = Smi::cast(args[2]).value();
+  int value = Smi::cast(args[3]).value();
+  bool is_read = (value >> 8) & 1;
+  value = value & ((1<<8)-1);
+
+  void *tagged_addr = tagged_list[idx]; 
+
+  if (isDouble) {
+    double *ptr = (double *)tagged_addr;
+    if (is_read) {
+      return *isolate->factory()->NewNumberFromInt64((uint64_t)(ptr[offset]));
+    } else {
+      ptr[offset] = (double)value;
+      return ReadOnlyRoots(isolate).undefined_value();
+    }
+  } else {
+    uint64_t *ptr = (uint64_t *)tagged_addr;
+    if (is_read) {
+      return *isolate->factory()->NewNumberFromInt64(ptr[offset]);
+    } else {
+      ptr[offset] = (uint64_t)value;
+      return ReadOnlyRoots(isolate).undefined_value();
+    }
+  }
+}
+
+
+// Output: target tag
+RUNTIME_FUNCTION(Runtime_ReAlloc) {
+  HandleScope scope(isolate);
+  if (args.length() != 2) {
+    return CrashUnlessFuzzing(isolate);
+  }
+
+  int isDouble = Smi::cast(args[0]).value();
+  int idx = Smi::cast(args[1]).value();
+  void *tagged_addr;
+  if (isDouble) {
+    delete[] (double*)tagged_list[idx];
+    tagged_addr = new double[0x80];
+    for (int j=0; j < 0x80; ++j) {
+      ((double*)tagged_addr)[j] = (double)(idx);
+    }
+    tagged_list[idx] = tagged_addr; 
+  } else {
+    delete[] (uint64_t*)tagged_list[idx];
+    tagged_addr = new uint64_t[0x80];
+    for (int j=0; j < 0x80; ++j) {
+      ((uint64_t*)tagged_addr)[j] = (uint64_t)(idx);
+    }
+    tagged_list[idx] = tagged_addr;
+  }
+
+  int new_tag = (int)(((uint64_t)tagged_addr & 0xf00000000000000) >> 56);
+  
+  return Smi::FromInt(new_tag);
+}
+
+// Arg 0: object
+// Output: value of the target address offset from the object
+RUNTIME_FUNCTION(Runtime_GetValue) {
+  HandleScope scope(isolate);
+  if (args.length() != 2) {
+    return CrashUnlessFuzzing(isolate);
+  }
+
+  Handle<Object> object = args.at(0);
+  uint64_t offset = PositiveNumberToUint64(args[1]);
+  void *backing_store = nullptr;
+  void *read_ptr = nullptr;
+  uint64_t value = 0;
+  int isDouble = 0;
+  if (IsJSTypedArray(*object)) {
+    Handle<JSTypedArray> js_typed_array = Handle<JSTypedArray>::cast(object);
+    if (offset == 1234) {  
+      // return typedarray ptr
+      return *isolate->factory()->NewNumberFromInt64((int64_t)(js_typed_array->ptr()-1));
+    }
+    backing_store = static_cast<void*>(js_typed_array->DataPtr());
+    read_ptr = (char*)backing_store+offset;
+    if ((js_typed_array->byte_length() / js_typed_array->GetLength()) == 8) {
+      isDouble = 1; // Double array
+    }
+  } else if (IsJSArray(*object)) {
+    Handle<JSArray> js_array = Handle<JSArray>::cast(object);
+    backing_store = (void*)(js_array->elements().ptr()-1+8);
+    read_ptr = (char*)backing_store + offset;
+  }
+
+  if (isDouble == 1)
+    value = (uint64_t)(*(double*)read_ptr);
+  else
+    value = *(uint64_t*)read_ptr;
+  return *isolate->factory()->NewNumberFromInt64(value);
+}
+
+RUNTIME_FUNCTION(Runtime_GetDataPtr) {
+  HandleScope scope(isolate);
+  if (args.length() != 1) {
+    return CrashUnlessFuzzing(isolate);
+  }
+
+  Handle<Object> object = args.at(0);
+
+  void *backing_store = nullptr;
+
+  if (IsJSTypedArray(*object)) {
+    Handle<JSTypedArray> js_typed_array = Handle<JSTypedArray>::cast(object);
+    backing_store = static_cast<void*>(js_typed_array->DataPtr());
+  } else if (IsJSArray(*object)) {
+    Handle<JSArray> js_array = Handle<JSArray>::cast(object);
+    backing_store = (void*)(js_array->elements().ptr()-1+8);
+  } 
+
+  return *isolate->factory()->NewNumberFromInt64((int64_t)backing_store);
+}
+
+RUNTIME_FUNCTION(Runtime_SetCore) {
+  HandleScope scope(isolate);
+  if (args.length() != 1) {
+    return CrashUnlessFuzzing(isolate);
+  }
+
+  int core = Smi::cast(args[0]).value();
+  int res;
+  cpu_set_t cpu_set;
+  CPU_ZERO(&cpu_set);
+  CPU_SET(core, &cpu_set);
+  if(-1 == sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set)) {
+    core |= (errno << 4);
+  }
+
+  res = sched_getcpu();
+  return Smi::FromInt(res);
+}
+
 namespace {
 
 void FinalizeOptimization(Isolate* isolate) {
@@ -1495,7 +2065,7 @@ RUNTIME_FUNCTION(Runtime_AbortCSADcheck) {
 
 RUNTIME_FUNCTION(Runtime_DisassembleFunction) {
   HandleScope scope(isolate);
-#ifdef DEBUG
+//#ifdef DEBUG
   if (args.length() != 1) {
     return CrashUnlessFuzzing(isolate);
   }
@@ -1511,7 +2081,7 @@ RUNTIME_FUNCTION(Runtime_DisassembleFunction) {
   StdoutStream os;
   Print(func->code(), os);
   os << std::endl;
-#endif  // DEBUG
+//#endif  // DEBUG
   return ReadOnlyRoots(isolate).undefined_value();
 }
 
diff --git a/src/runtime/runtime.h b/src/runtime/runtime.h
index eff1cc9869b..493e10b9870 100644
--- a/src/runtime/runtime.h
+++ b/src/runtime/runtime.h
@@ -520,6 +520,22 @@ namespace internal {
   F(DebugPrintWord, 5, 1)                     \
   F(DebugTrace, 0, 1)                         \
   F(DebugTrackRetainingPath, -1, 1)           \
+  F(FlushLength, 1, 1)                        \
+  F(FlushAddress, 2, 1)                       \
+  F(VirtualCount, 2, 1)                       \
+  F(VirtualCountLength, 2, 1)                 \
+  F(SharedCount, 2, 1)                        \
+  F(SharedCountLength, 2, 1)                  \
+  F(StartSharedCount, 0, 1)                   \
+  F(GetTaggedAddress, 3, 1)                   \
+  F(Initialize, 2, 1)                             \
+  F(FreeObj, 2, 1)                         \
+  F(AllocObj, 2, 1)                         \
+  F(AccessObj, 4, 1)                         \
+  F(ReAlloc, 2, 1)                         \
+  F(GetDataPtr, 1, 1)                         \
+  F(GetValue, 2, 1)                           \
+  F(SetCore, 1, 1)                            \
   F(DeoptimizeFunction, 1, 1)                 \
   F(DisableOptimizationFinalization, 0, 1)    \
   F(DisallowCodegenFromStrings, 1, 1)         \
